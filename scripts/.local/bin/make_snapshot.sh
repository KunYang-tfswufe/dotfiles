#!/usr/bin/env bash

# --- Configuration ---

# 1. Set the name of the output file
output_file="project_snapshot.txt"

# 2. List of directories to ignore by default (folder names)
#    All content within these directories will be skipped.
ignored_dirs=(
    .git
    .vscode
    .idea
    .obsidian
    .metadata
    node_modules
    target
    build
    dist
    __pycache__

    # --- STM32CubeIDE specific folders to ignore ---
    "Debug"      # Contains compiled binaries and object files (.o, .elf)
    "Drivers"    # Contains ST's standard HAL/CMSIS library files
    ".settings"  # Contains local IDE workspace settings
)

# 3. List of files to ignore by default (full filenames or wildcards)
ignored_files=(
    "*.log"
    "*.swp"
    "*.bak"
    "$output_file" # Ensure the output file itself is not included

    # --- Add these lines to ignore license files ---
    "LICENSE"       # Ignores the exact file "LICENSE"
    "LICENSE.*"     # Ignores files like "LICENSE.md", "LICENSE.txt"
    "COPYING"       # Ignores the GNU-style license file "COPYING"
    "COPYING.*"     # Ignores files like "COPYING.LESSER"
    "NOTICE"        # Ignores the "NOTICE" file, often with Apache License
    "NOTICE.*"
    "UNLICENSE"     # Ignores the "UNLICENSE" file

    # --- STM32CubeIDE specific files to ignore ---
    "*.launch"     # IDE debug launch configurations
    "*.map"        # Linker map files
    "*.list"       # Assembly listing files
)
# --- Script Main Body ---

echo "Starting project snapshot generation..."

# Prepare ignore parameters for the find command
find_ignore_params=()
for dir in "${ignored_dirs[@]}"; do
    # -prune prevents find from entering the directory, which is very efficient
    find_ignore_params+=(-name "$dir" -prune -o)
done
for file in "${ignored_files[@]}"; do
    find_ignore_params+=(-name "$file" -prune -o)
done

# Clear or create the output file and prepare to write
# ">" will overwrite the old file
echo "# This is a project snapshot generated by the script on $(date)" > "$output_file"
echo "----------------------------------------------------" >> "$output_file"
echo "" >> "$output_file"

# Use find to locate all matching files
# -type f: select only files
# -print0: use null characters to separate filenames for safe handling of special characters
file_list=()
while IFS= read -r -d $'\0' file; do
    file_list+=("$file")
done < <(find . "${find_ignore_params[@]}" -type f -print0)


# Check if any files were found
if [ ${#file_list[@]} -eq 0 ]; then
    echo "Warning: No matching files found in the current directory."
    exit 0
fi

echo "Found ${#file_list[@]} files. Processing..."

# Loop through and process each found file
for file in "${file_list[@]}"; do
    # Filter out binary files
    mime_type=$(file -b --mime-type "$file")
    if [[ "$mime_type" == "text/"* || "$mime_type" == "application/json" || "$mime_type" == "application/xml" || "$mime_type" == "application/javascript" || "$mime_type" == "application/x-sh" || "$mime_type" == "application/x-c" || "$mime_type" == "application/x-c++" ]]; then
        # It's a text file, process it

        # 1. Write the file path header to the output file
        echo "--- START OF FILE: $file ---" >> "$output_file"
        echo "" >> "$output_file" # Add a blank line

        # 2. Append the file content to the output file
        cat "$file" >> "$output_file"

        # 3. Write the end marker and separator after the content
        echo "" >> "$output_file" # Add a blank line
        echo "--- END OF FILE: $file ---" >> "$output_file"
        echo -e "\n\n" >> "$output_file" # Use two newlines to separate files

        echo "  - Processed: $file"
    else
        # It's a binary file, skip it
        echo "  - (Binary file, ignored): $file"
    fi
done

echo "Done! All text file contents have been merged into '$output_file'."
